package numerics

import (
	"math"
	"testing"
)

func TestBetaComplete(t *testing.T) {

	type testCaseBetaComplete struct {
		a, b     float64
		expected float64
	}

	var testTableBetaComplete = []testCaseBetaComplete{
		{0.50, 0.50, 3.1415926535897935601},
		{1.00, 0.50, 2.},
		{1.00, 1.00, 1.0},
		{1.00, 2.00, 0.5},
		{1.00, 3.00, 0.33333333333333333},
		{1.00, 4.00, 0.25},
		{1.00, 5.00, 0.2},
		{2.00, 2.00, 0.16666666666666666},
		{3.00, 2.00, 0.08333333333333333},
		{4.00, 2.00, 0.05},
		{5.00, 2.00, 0.03333333333333333},
		{5.50, 5.00, 0.0011084890341856285488},
		{10.00, 0.50, 0.56754638550304181699},
		{10.00, 5.00, 0.000099900099900099900013},
		{10.00, 10.00, 1.0825088224469028797E-6},
		{20.00, 5.00, 4.7054394880481842855E-6},
		{20.00, 10.00, 4.9925087406346786552E-9},
		{20.00, 20.00, 7.2544445519248445760E-13},
		{30.00, 10.00, 1.5729567312509353417E-10},
		{40.00, 20.00, 1.7891885039182104013E-17},
		{1.31, 11.76, 0.034893647244516490247},
	}

	for _, cs := range testTableBetaComplete {
		if beta := Beta(cs.a, cs.b); math.Abs(beta-cs.expected) > betaEpsilon {
			t.Fatalf("Test driven call to Beta failed (a=%.3f, b=%.3f), want %.19f, have %.19f", cs.a, cs.b, cs.expected, beta)
		}
	}
}

func TestBetaIncomplete(t *testing.T) {

	type testCaseBetaIncomplete struct {
		x, a, b  float64
		expected float64
	}

	var testTableBetaIncomplete = []testCaseBetaIncomplete{
		{-1., 0.50, 0.50, math.NaN()},
		{10., 0.50, 0.50, math.NaN()},
		{0.01, 0.50, 0.50, 0.6376856085851985E-01},
		{0.10, 0.50, 0.50, 0.2048327646991335},
		{1.00, 0.50, 0.50, 1.000000000000000},
		{0.00, 1.00, 0.50, 0.000000000000000},
		{0.01, 1.00, 0.50, 0.5012562893380045E-02},
		{0.10, 1.00, 0.50, 0.5131670194948620E-01},
		{0.50, 1.00, 0.50, 0.2928932188134525},
		{0.50, 1.00, 1.00, 0.5000000000000000},
		{0.10, 2.00, 2.00, 0.2800000000000000E-01},
		{0.20, 2.00, 2.00, 0.1040000000000000},
		{0.30, 2.00, 2.00, 0.2160000000000000},
		{0.40, 2.00, 2.00, 0.3520000000000000},
		{0.50, 2.00, 2.00, 0.5000000000000000},
		{0.60, 2.00, 2.00, 0.6480000000000000},
		{0.70, 2.00, 2.00, 0.7840000000000000},
		{0.80, 2.00, 2.00, 0.8960000000000000},
		{0.90, 2.00, 2.00, 0.9720000000000000},
		{0.50, 5.50, 5.00, 0.4361908850559777},
		{0.90, 10.00, 0.50, 0.1516409096347099},
		{0.50, 10.00, 5.00, 0.8978271484375000E-01},
		{1.00, 10.00, 5.00, 1.000000000000000},
		{0.50, 10.00, 10.00, 0.5000000000000000},
		{0.80, 20.00, 5.00, 0.4598773297575791},
		{0.60, 20.00, 10.00, 0.2146816102371739},
		{0.80, 20.00, 10.00, 0.9507364826957875},
		{0.50, 20.00, 20.00, 0.5000000000000000},
		{0.60, 20.00, 20.00, 0.8979413687105918},
		{0.70, 30.00, 10.00, 0.2241297491808366},
		{0.80, 30.00, 10.00, 0.7586405487192086},
		{0.70, 40.00, 20.00, 0.7001783247477069},
		{0.10, 1.00, 0.50, 0.5131670194948620E-01},
		{0.20, 1.00, 0.50, 0.1055728090000841},
		{0.30, 1.00, 0.50, 0.1633399734659245},
		{0.40, 1.00, 0.50, 0.2254033307585166},
		{0.20, 1.00, 2.00, 0.3600000000000000},
		{0.20, 1.00, 3.00, 0.4880000000000000},
		{0.20, 1.00, 4.00, 0.5904000000000000},
		{0.20, 1.00, 5.00, 0.6723200000000000},
		{0.30, 2.00, 2.00, 0.2160000000000000},
		{0.30, 3.00, 2.00, 0.8370000000000000E-01},
		{0.30, 4.00, 2.00, 0.3078000000000000E-01},
		{0.30, 5.00, 2.00, 0.1093500000000000E-01},
		{0.23, 1.31, 11.76, 0.9234481429287121346},
		{0.03, 1.31, 11.76, 0.1846748359068621226},
		{0.03, 1.31, 11.76, 0.1846748359068621226},
		{0.5, -1E99, -1E99, math.NaN()},
		{0.5, 1E99, 1E99, math.NaN()},
	}

	for _, cs := range testTableBetaIncomplete {
		if betaReg := BetaIncompleteRegular(cs.x, cs.a, cs.b); math.Abs(betaReg-cs.expected) > betaEpsilon {
			t.Fatalf("Test driven call to BetaIncompleteRegular failed (x=%.3f, a=%.3f, b=%.3f), want %.19f, have %.19f", cs.x, cs.a, cs.b, cs.expected, betaReg)
		}

		if beta := BetaIncomplete(cs.x, cs.a, cs.b); math.Abs(beta-cs.expected*Beta(cs.a, cs.b)) > betaEpsilon {
			t.Fatalf("Test driven call to BetaIncomplete failed (x=%.3f, a=%.3f, b=%.3f), want %.19f, have %.19f", cs.x, cs.a, cs.b, cs.expected*Beta(cs.a, cs.b), beta)
		}
	}
}

func TestBinomial(t *testing.T) {

	type testCaseBinomial struct {
		x, a, b  float64
		expected float64
	}

	var testTableBinomial = []testCaseBinomial{
		{-1.00, 0.50, 0.50, math.NaN()},
		{10.00, 0.50, 0.50, math.NaN()},
		{0.01, 0.50, 0.50, 9.90000000000000035527},
		{0.10, 0.50, 0.50, 2.84604989415154108201},
		{1.00, 0.50, 0.50, 0.00000000000000000000},
		{0.00, 1.00, 0.50, math.NaN()},
		{0.01, 1.00, 0.50, 0.99498743710661996520},
		{0.10, 1.00, 0.50, 0.94868329805051376802},
		{0.50, 1.00, 0.50, 0.70710678118654757274},
		{0.50, 1.00, 1.00, 0.50000000000000000000},
		{0.10, 2.00, 2.00, 0.09000000000000001055},
		{0.20, 2.00, 2.00, 0.16000000000000003109},
		{0.30, 2.00, 2.00, 0.20999999999999996447},
		{0.40, 2.00, 2.00, 0.24000000000000004663},
		{0.50, 2.00, 2.00, 0.25000000000000000000},
		{0.60, 2.00, 2.00, 0.24000000000000004663},
		{0.70, 2.00, 2.00, 0.20999999999999999223},
		{0.80, 2.00, 2.00, 0.15999999999999997558},
		{0.90, 2.00, 2.00, 0.08999999999999996891},
		{0.50, 5.50, 5.00, 0.03125000000000000000},
		{0.90, 10.00, 0.50, 122513115.74562112987041473389},
		{0.50, 10.00, 5.00, 0.03125000000000000000},
		{1.00, 10.00, 5.00, math.Inf(1)},
		{0.50, 10.00, 10.00, 0.00097656250000000000},
		{0.80, 20.00, 5.00, 87960930.22208030521869659424},
		{0.60, 20.00, 10.00, 0.23245229339999987084},
		{0.80, 20.00, 10.00, 28147.49767106560830143280},
		{0.50, 20.00, 20.00, 0.00000095367431640625},
		{0.60, 20.00, 20.00, 0.00002437438960041986},
		{0.70, 30.00, 10.00, 277037.98561990616144612432},
		{0.80, 30.00, 10.00, 29514790517.93544769287109375000},
		{0.70, 40.00, 20.00, 7825.63739704412182618398},
		{0.10, 1.00, 0.50, 0.94868329805051376802},
		{0.20, 1.00, 0.50, 0.89442719099991585541},
		{0.30, 1.00, 0.50, 0.83666002653407556267},
		{0.40, 1.00, 0.50, 0.77459666924148340428},
		{0.20, 1.00, 2.00, 0.64000000000000001332},
		{0.20, 1.00, 3.00, 0.51200000000000012168},
		{0.20, 1.00, 4.00, 0.40960000000000007514},
		{0.20, 1.00, 5.00, 0.32768000000000008232},
		{0.30, 2.00, 2.00, 0.20999999999999996447},
		{0.30, 3.00, 2.00, 0.08999999999999996891},
		{0.30, 4.00, 2.00, 0.03857142857142854819},
		{0.30, 5.00, 2.00, 0.01653061224489795270},
		{0.23, 1.31, 11.76, 0.03180199993749933257},
		{0.03, 1.31, 11.76, 0.23792711924420170688},
		{0.03, 1.31, 11.76, 0.23792711924420170688},
		{0.5, -1E99, -1E99, math.Inf(1)},
		{0.5, 1E99, 1E99, 0.},
	}

	for _, cs := range testTableBinomial {
		if binomial := Binomial(cs.x, cs.a-1., cs.b); math.Abs(binomial-cs.expected) > betaEpsilon {
			t.Fatalf("Test driven call to Binomial failed (x=%.3f, a=%.3f, b=%.3f), want %.19f, have %.19f", cs.x, cs.a, cs.b, cs.expected, binomial)
		}
	}
}

func TestSign(t *testing.T) {

	type testCaseSign struct {
		x        float64
		expected int
	}

	var testTableSign = []testCaseSign{
		{0., 0},
		{-1., -1},
		{1., 1},
		{-math.MaxFloat64, -1},
		{math.MaxFloat64, 1},
		{-math.SmallestNonzeroFloat64, -1},
		{math.SmallestNonzeroFloat64, 1},
		{math.Inf(-1), -1},
		{math.Inf(1), 1},
		{math.NaN(), 0},
	}

	for _, cs := range testTableSign {
		if sign := Sign(cs.x); sign != cs.expected {
			t.Fatalf("Test driven call to Sign failed (x=%.3f), want %d, have %d", cs.x, cs.expected, sign)
		}
	}

}

////////////////////////////////////////////////////////////////////////////////

func relDeviation(a, b float64) float64 {
	return math.Abs(a-b) / a
}
